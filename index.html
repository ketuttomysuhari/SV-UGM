<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>IFC → Cesium | GUID zoom, IFC coords, Stats, Rooms</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.130/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.130/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <style>
    html, body, #cesiumContainer { width:100%; height:100%; margin:0; padding:0; overflow:hidden; }
    /* UI blocks */
    .ui-left { position:absolute; top:10px; left:10px; z-index:1000; display:flex; gap:8px; align-items:center; }
    .ui-right { position:absolute; top:66px; right:10px; z-index:1000; display:flex; flex-direction:column; gap:8px; }
    .card { background:#ffffffd9; backdrop-filter: blur(6px); border:1px solid #e5e7eb; border-radius:12px; padding:10px 12px; box-shadow:0 4px 14px rgba(0,0,0,.08); }
    .row { display:flex; gap:6px; align-items:center; flex-wrap:wrap; }
    .row input, .row button, .row label { font: 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .row input[type="text"] { padding:6px 8px; border:1px solid #d1d5db; border-radius:8px; min-width:220px; }
    .row button { padding:6px 10px; border:1px solid #d1d5db; background:white; border-radius:8px; cursor:pointer; }
    .row button:hover { background:#f3f4f6; }
    .badge { display:inline-block; font-size:11px; padding:2px 6px; border-radius:999px; background:#eef2ff; border:1px solid #c7d2fe; color:#3730a3; margin-right:6px; }
    .pre { margin:0; font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; white-space:pre-wrap; }
    .logo { position:absolute; bottom:16px; right:16px; z-index:1000; opacity:0.9; }
    .logo img { width:140px; }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>

  <!-- LEFT: Search & Actions -->
  <div class="ui-left card">
    <div class="row">
      <span class="badge">GUID</span>
      <input id="guidInput" type="text" placeholder="IfcGUID" />
      <button id="btnGuid">Highlight & Fly</button>
      <span class="badge">Room</span>
      <input id="roomInput" type="text" placeholder="Exact Name (e.g., MUSHOLA)" />
      <button id="btnRoom">Find Room</button>
      <label class="badge" for="ifcFile">IFC Geo</label>
      <input id="ifcFile" type="file" accept=".ifc" />
      <button id="btnScan">Scan Stats</button>
    </div>
  </div>

  <!-- RIGHT: Info & Stats (under geocoder at top-right) -->
  <div class="ui-right">
    <div class="card">
      <div style="font-weight:600; margin-bottom:6px;">Picked feature</div>
      <pre id="pickedInfo" class="pre">Click an element…</pre>
    </div>
    <div class="card">
      <div style="font-weight:600; margin-bottom:6px;">Model stats</div>
      <pre id="stats" class="pre">Windows: 0 | Doors: 0 | Storeys: -
(Lanjutkan dengan tombol "Scan Stats")</pre>
    </div>
    <div class="card">
      <div style="font-weight:600; margin-bottom:6px;">Floors & Rooms</div>
      <div id="levelsPanel" class="pre">(Tekan "Scan Stats" untuk menampilkan daftar lantai & ruang)</div>
    </div>
  </div>

  <div class="logo"><img src="https://sv.ugm.ac.id/wp-content/uploads/sites/27/2021/09/Lambang-UGM-putih.png" alt="logo"/></div>

  <script type="module">
    // ─────────────────────────────────────────────────────────────────────
    // Init Cesium
    // ─────────────────────────────────────────────────────────────────────
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJiNDJhNGIzMy1lYjk1LTQ5MTgtOGIxMy1iMjNkYWFjZTZjZGMiLCJpZCI6MzA1NDUzLCJpYXQiOjE3NDk4ODQ0NjF9.ZzfqWk4Sc_3zrTXoyumAzAVH4QavWxwZ5kLWHN6KZ4E';

    const viewer = new Cesium.Viewer('cesiumContainer', {
      terrain: Cesium.Terrain.fromWorldTerrain(),
      animation:false, timeline:false, homeButton:false,
      sceneModePicker:false, geocoder:true, baseLayerPicker:true,
      navigationHelpButton:false, fullscreenButton:true,
      selectionIndicator:false, infoBox:false
    });

    // Slightly more realistic & less bright appearance
    viewer.scene.shadowMap.enabled = true;
    viewer.shadows = true;
    viewer.scene.highDynamicRange = true;
    // Enable globe lighting for a less-flat look (safer than style mix)
viewer.scene.globe.enableLighting = true;

    viewer.camera.flyTo({
      destination: Cesium.Cartesian3.fromDegrees(110.37394, -7.77463, 400),
      orientation: { heading: Cesium.Math.toRadians(0.0), pitch: Cesium.Math.toRadians(-90.0) }
    });

    const tileset = await Cesium.Cesium3DTileset.fromIonAssetId(3591078);
    viewer.scene.primitives.add(tileset);
    await tileset.readyPromise;
    viewer.zoomTo(tileset);

    // Keep default style; avoid risky color mixing that can crash on undefined COLORcatch(e){} }

    // ─────────────────────────────────────────────────────────────────────
    // Helpers
    // ─────────────────────────────────────────────────────────────────────
    const pickedInfo = document.getElementById('pickedInfo');
    const statsBox = document.getElementById('stats');

    let lastColored = [];
    function clearHighlight(){ for(const f of lastColored){ try{ f.color = Cesium.Color.WHITE; }catch(_){} } lastColored.length=0; }
    function highlightFeature(f){ try{ f.color = Cesium.Color.YELLOW; lastColored.push(f); }catch(_){} }

    // Screen grid scan to fly to a feature that satisfies predicate(feature)
    async function flyToMatch(predicate, options={}){
      const w = viewer.canvas.clientWidth, h = viewer.canvas.clientHeight;
      const steps = 7;
      for(let iy=1; iy<steps; iy++){
        for(let ix=1; ix<steps; ix++){
          const pt = new Cesium.Cartesian2(Math.round((ix/steps)*w), Math.round((iy/steps)*h));
          const picked = viewer.scene.drillPick(pt);
          for(const p of picked){
            if(typeof p.getProperty !== 'function') continue;
            try { if(predicate(p)){
              const cart = viewer.scene.pickPosition(pt);
              if(Cesium.defined(cart)){
                const carto = Cesium.Cartographic.fromCartesian(cart);
                const H = carto.height;
                viewer.camera.flyTo({
                  destination: Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, Math.max(8.0, H+18.0)),
                  orientation: { heading: viewer.camera.heading, pitch: Cesium.Math.toRadians(-35), roll: 0 },
                  duration: options.duration ?? 1.0
                });
                return true;
              }
            }} catch(_){}
          }
        }
      }
      return false;
    }

    // IFC MapConversion storage for projected coords
    const IFCGeo = { has:false, Eastings:0, Northings:0, OrthogonalHeight:0, Scale:1, XAxisAbscissa:1, XAxisOrdinate:0 };
    function projectLocalToMap(xLocal, yLocal){
      const Xp = xLocal*IFCGeo.XAxisAbscissa + yLocal*IFCGeo.XAxisOrdinate;
      const Yp = xLocal*(-IFCGeo.XAxisOrdinate) + yLocal*IFCGeo.XAxisAbscissa;
      return { Xmap: IFCGeo.Eastings + IFCGeo.Scale*Xp, Ymap: IFCGeo.Northings + IFCGeo.Scale*Yp };
    }

    // ─────────────────────────────────────────────────────────────────────
    // Picking
    // ─────────────────────────────────────────────────────────────────────
    const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
    handler.setInputAction((click) => {
      const picked = viewer.scene.pick(click.position);
      if(!picked || typeof picked.getProperty !== 'function') return;
      clearHighlight();
      highlightFeature(picked);

      const cart = viewer.scene.pickPosition(click.position);
      let coordText = 'n/a';
      let mapText = '';
      if(Cesium.defined(cart)){
        const carto = Cesium.Cartographic.fromCartesian(cart);
        const lon = Cesium.Math.toDegrees(carto.longitude);
        const lat = Cesium.Math.toDegrees(carto.latitude);
        const h   = carto.height;
        coordText = `lon: ${lon.toFixed(7)}\nlat: ${lat.toFixed(7)}\nh:   ${h.toFixed(3)} m`;

        if(IFCGeo.has){
          const modelMatrix = tileset.root.computedTransform || tileset.root.transform;
          const inv = Cesium.Matrix4.inverse(modelMatrix, new Cesium.Matrix4());
          const local = Cesium.Matrix4.multiplyByPoint(inv, cart, new Cesium.Cartesian3());
          const XY = projectLocalToMap(local.x, local.y);
          mapText = `\nX_map: ${XY.Xmap.toFixed(3)}\nY_map: ${XY.Ymap.toFixed(3)}`;
        }

        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, Math.max(8.0, h + 20.0)),
          orientation: { heading: viewer.camera.heading, pitch: Cesium.Math.toRadians(-35), roll: 0 },
          duration: 0.9
        });
      }

      const ids = (picked.getPropertyIds && picked.getPropertyIds()) || [];
      const props = {}; for(const id of ids){ props[id] = picked.getProperty(id); }
      const ifcGuid = props.IfcGuid || props.IFC_GUID || props.GlobalId || props.globalId || props.elementId;
      const ifcType = props.IfcType || props.ifcClass || props.class || props.Type || props.Category;

      const out = [
        `# BIM feature`,
        ifcGuid ? `IfcGUID: ${ifcGuid}` : null,
        ifcType ? `Type:    ${ifcType}` : null,
        `\n# All properties`,
        JSON.stringify(props, null, 2),
        `\n# Pick position (WGS84)`,
        coordText,
        IFCGeo.has ? `\n# IFC MapConversion (projected)\n${mapText}` : null
      ].filter(Boolean).join('\n');

      pickedInfo.textContent = out;
      // Build attribute table view
      const tbody = document.querySelector('#attrTable tbody');
      if(tbody){
        tbody.innerHTML='';
        Object.keys(props).sort().forEach(k=>{
          const tr=document.createElement('tr');
          tr.innerHTML=`<td style="vertical-align:top; padding:2px 6px; border-bottom:1px solid #f0f0f0">${k}</td>`+
                       `<td style=\"vertical-align:top; padding:2px 6px; border-bottom:1px solid #f0f0f0; word-break:break-all\">${String(props[k])}</td>`;
          tbody.appendChild(tr);
        });
      }
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    handler.setInputAction(() => clearHighlight(), Cesium.ScreenSpaceEventType.RIGHT_CLICK);

    // ─────────────────────────────────────────────────────────────────────
    // GUID filter + auto-zoom (fix: escape ${} in style string with \$)
    // ─────────────────────────────────────────────────────────────────────
    const guidInput = document.getElementById('guidInput');
    document.getElementById('btnGuid').addEventListener('click', async () => {
      const guid = (guidInput.value || '').trim();
      if(!guid){ tileset.style = undefined; return; }
      const pat = guid.replace(/'/g, "\'");
      const conditions = [
        ["regexp('"+pat+"','i').test(\${IfcGuid}) || regexp('"+pat+"','i').test(\${GlobalId}) || regexp('"+pat+"','i').test(\${IFC_GUID}) || regexp('"+pat+"','i').test(\${elementId})", "color('yellow', 1.0)"],
        ['true', "color('white', 0.85)"]
      ];
      try { tileset.style = new Cesium.Cesium3DTileStyle({ color: { conditions } }); } catch(_) { tileset.style = undefined; }

      const ok = await flyToMatch(f => {
        const val = f.getProperty('IfcGuid') || f.getProperty('GlobalId') || f.getProperty('IFC_GUID') || f.getProperty('elementId');
        return val && String(val).toLowerCase().includes(guid.toLowerCase());
      }, { duration: 0.9 });
      if(!ok){ viewer.flyTo(tileset, { duration: 0.8 }); }
    });

      const ok = await flyToMatch(f => {
        const val = f.getProperty('IfcGuid') || f.getProperty('GlobalId') || f.getProperty('IFC_GUID') || f.getProperty('elementId');
        return val && String(val).trim() === guid;
      }, { duration: 0.9 });
      if(!ok){ viewer.flyTo(tileset, { duration: 0.8 }); }
    });

    // ─────────────────────────────────────────────────────────────────────
    // Find room by exact Name (e.g., "MUSHOLA") and fly to it
    // ─────────────────────────────────────────────────────────────────────
    const roomInput = document.getElementById('roomInput');
    document.getElementById('btnRoom').addEventListener('click', async () => {
      const name = (roomInput.value || '').trim(); if(!name) return;
      const pat = name.replace(/'/g, "\'");
      const conditions = [
        ["regexp('"+pat+"','i').test(\${Name}) || regexp('"+pat+"','i').test(\${LongName}) || regexp('"+pat+"','i').test(\${Room})", "color('orange', 1.0)"],
        ['true', "color('white', 0.85)"]
      ];
      try { tileset.style = new Cesium.Cesium3DTileStyle({ color: { conditions } }); } catch(_){}

      const ok = await flyToMatch(f => {
        const pnames = ['Name','name','LongName','Room'];
        for(const k of pnames){ const v = f.getProperty(k); if(v && String(v).toLowerCase().includes(name.toLowerCase())) return true; }
        return false;
      }, { duration: 0.9 });
      if(!ok){ viewer.flyTo(tileset, { duration: 0.8 }); }
    }); } catch(_){}

      const ok = await flyToMatch(f => {
        const pnames = ['Name','name','LongName','Room'];
        for(const k of pnames){ const v = f.getProperty(k); if(v && String(v).trim() === name) return true; }
        return false;
      }, { duration: 0.9 });
      if(!ok){ viewer.flyTo(tileset, { duration: 0.8 }); }
    });

    // ─────────────────────────────────────────────────────────────────────
    // Stats scan: count Doors/Windows & storey listing (best-effort from props)
    // ─────────────────────────────────────────────────────────────────────
    const seen = new Set();
    const counts = { windows:0, doors:0 };
    const storeys = new Map(); // name -> count
    const roomsByStorey = new Map(); // storey -> Set(names)

    function considerFeature(f){
      const guid = f.getProperty('IfcGuid') || f.getProperty('GlobalId') || f.getProperty('elementId');
      if(guid && seen.has(guid)) return; if(guid) seen.add(guid);
      const type = (f.getProperty('IfcType') || f.getProperty('ifcClass') || f.getProperty('class') || f.getProperty('Type') || '').toString();
      const name = (f.getProperty('Name') || f.getProperty('name') || f.getProperty('LongName') || '').toString();
      const storey = (f.getProperty('Storey') || f.getProperty('Level') || f.getProperty('BuildingStorey') || f.getProperty('Floor') || '').toString();

      if(/IfcWindow/i.test(type) || /(^|)window/i.test(type)) counts.windows++;
      if(/IfcDoor/i.test(type) || /(^|)door/i.test(type)) counts.doors++;

      if(storey){ storeys.set(storey, (storeys.get(storey)||0) + 1); }

      // Guess rooms: IfcSpace/Space/Room
      if(/IfcSpace/i.test(type) || /(^|)(space|room)/i.test(type)){
        const key = storey || '(No Storey)';
        if(!roomsByStorey.has(key)) roomsByStorey.set(key, new Set());
        if(name) roomsByStorey.get(key).add(name);
      }
    }

    function processTile(tile){
      const c = tile.content; const n = c?.featuresLength || 0;
      for(let i=0;i<n;i++){ const f=c.getFeature(i); considerFeature(f); }
    }

    function refreshStatsBox(){
      const levels = [...storeys.keys()].sort();
      let lines = `Windows: ${counts.windows} | Doors: ${counts.doors}`;
      if(levels.length){
        lines += `
Storeys (${levels.length}):`;
        for(const lv of levels){ lines += `
- ${lv}: ${storeys.get(lv)} elemen`; }
      }
      statsBox.textContent = lines;
    }

    function renderLevelsPanel(){
      const el = document.getElementById('levelsPanel');
      if(!roomsByStorey.size){ el.textContent = '(Tidak ada data ruang terdeteksi)'; return; }
      let html = '';
      for(const [level, rooms] of roomsByStorey){
        html += `<div style="margin:6px 0; font-weight:600;">${level}</div>`;
        const arr = Array.from(rooms).sort();
        html += `<div style="display:flex; flex-wrap:wrap; gap:4px;">`+
          arr.map(r=>`<button class="room-btn" data-room="${r.replace(/"/g,'&quot;')}">${r}</button>`).join('')+
          `</div>`;
      }
      el.innerHTML = html;
      el.querySelectorAll('.room-btn').forEach(btn=>{
        btn.addEventListener('click', async ()=>{
          const name = btn.getAttribute('data-room');
          roomInput.value = name;
          const pat = name.replace(/'/g, "\'");
          const conditions = [
            ["regexp('"+pat+"','i').test(\${Name}) || regexp('"+pat+"','i').test(\${LongName}) || regexp('"+pat+"','i').test(\${Room})", "color('orange', 1.0)"],
            ['true', "color('white', 0.85)"]
          ];
          try { tileset.style = new Cesium.Cesium3DTileStyle({ color: { conditions } }); } catch(_){ }
          const ok = await flyToMatch(f => {
            const pnames = ['Name','name','LongName','Room'];
            for(const k of pnames){ const v = f.getProperty(k); if(v && String(v).toLowerCase() === name.toLowerCase()) return true; }
            return false;
          }, { duration: 0.9 });
          if(!ok){ viewer.flyTo(tileset, { duration: 0.8 }); }
        });
      });
    } | Doors: ${counts.doors}`;
      if(levels.length){
        lines += `\nStoreys (${levels.length}):`;
        for(const lv of levels){ lines += `\n- ${lv}: ${storeys.get(lv)} elemen`; }
      }
      statsBox.textContent = lines;
    }

    document.getElementById('btnScan').addEventListener('click', () => {
      seen.clear(); counts.windows=0; counts.doors=0; storeys.clear(); roomsByStorey.clear();
      viewer.scene.frameState.commandList; // hint a render
      tileset._selectedTiles && tileset._selectedTiles.forEach(t=>processTile(t));
      tileset.tileVisible.addEventListener(processTile);
      refreshStatsBox();
      renderLevelsPanel();
    }); counts.windows=0; counts.doors=0; storeys.clear();
      // Scan visible
      viewer.scene.frameState.commandList; // hint a render
      tileset._selectedTiles && tileset._selectedTiles.forEach(t=>processTile(t));
      // Also attempt to scan when tiles become visible as you navigate
      tileset.tileVisible.addEventListener(processTile);
      refreshStatsBox();
    });

    // ─────────────────────────────────────────────────────────────────────
    // OPTIONAL: IFC georeferencing reader (IfcMapConversion/IfcSite)
    // ─────────────────────────────────────────────────────────────────────
    import { IfcAPI, IFCMAPCONVERSION, IFCSITE } from 'https://cdn.jsdelivr.net/npm/web-ifc@0.0.46/web-ifc-api.js';
    const ifcApi = new IfcAPI(); await ifcApi.Init(); ifcApi.SetWasmPath('https://cdn.jsdelivr.net/npm/web-ifc@0.0.46/');

    document.getElementById('ifcFile').addEventListener('change', async (e) => {
      const file = e.target.files?.[0]; if(!file) return;
      const buf = await file.arrayBuffer();
      const modelID = ifcApi.OpenModel(buf);
      try {
        let text = '# IFC Georeferencing\n';
        const ids = ifcApi.GetLineIDsWithType(modelID, IFCMAPCONVERSION);
        if(ids.size>0){
          const id = ids.get(0); const mc = ifcApi.GetLine(modelID, id);
          IFCGeo.has = true;
          IFCGeo.Eastings = mc.Eastings?.value ?? 0;
          IFCGeo.Northings = mc.Northings?.value ?? 0;
          IFCGeo.OrthogonalHeight = mc.OrthogonalHeight?.value ?? 0;
          IFCGeo.Scale = mc.Scale?.value ?? 1.0;
          IFCGeo.XAxisAbscissa = mc.XAxisAbscissa?.value ?? 1.0;
          IFCGeo.XAxisOrdinate = mc.XAxisOrdinate?.value ?? 0.0;
          text += `IfcMapConversion id ${id}\n  Eastings: ${IFCGeo.Eastings}\n  Northings: ${IFCGeo.Northings}\n  OrthogonalHeight: ${IFCGeo.OrthogonalHeight}\n  Scale: ${IFCGeo.Scale}\n  XAxisAbscissa: ${IFCGeo.XAxisAbscissa}\n  XAxisOrdinate: ${IFCGeo.XAxisOrdinate}\n`;
        } else {
          text += 'No IfcMapConversion found.';
        }
        pickedInfo.textContent = text;
      } catch(err){ pickedInfo.textContent = 'IFC parse error: '+err; }
      finally { ifcApi.CloseModel(modelID); }
    });
  // Floor filter handler (safe style)
    (function(){
      const btn = document.getElementById('btnFloor');
      if(!btn) return;
      btn.addEventListener('click', ()=>{
        const dd = document.getElementById('floorFilter');
        const lv = (dd && dd.value ? dd.value.trim() : '');
        if(!lv){ try{ tileset.style = new Cesium.Cesium3DTileStyle({ color: { conditions: [["true", "color('white', 0.85)"]] } }); }catch(_){}; return; }
        const pat = lv.replace(/'/g, "\'");
        const conditions = [
          ["regexp('"+pat+"','i').test(\${Storey}) || regexp('"+pat+"','i').test(\${Level}) || regexp('"+pat+"','i').test(\${BuildingStorey}) || regexp('"+pat+"','i').test(\${Floor})", "color('yellow', 1.0)"],
          ["true", "color('white', 0.2)"]
        ];
        try { tileset.style = new Cesium.Cesium3DTileStyle({ color: { conditions } }); } catch(_){}
      });
    })();
  </script>
</body>
</html>
